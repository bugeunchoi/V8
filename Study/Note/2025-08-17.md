9주 차 과제 이후 지속 분석 중인데, bt 이후 #36까지는 런타임 매크로를 통해 js 함수 인자를 받고 turbofan까지의 파이프라이닝을 하는 코드라고 유추하였다. (최종적으로 ExcuteJobImpl 매크로로 turboshaft pipeline으로
넘어가고, RUN<turboshaft::MaglevGraphBuildingPhase>(linkage)로 그래프를 그리기 시작(#36)하므로 이때의 코드부터 정적+동적 분석을 진행한다.(line #35)

우선 linkage가 그래프를 그리기 위해 필요한 데이터를 담은 구조체라고 생각되므로 아래와 같은 방법으로 구조체를 분석한다.

## 메모리 필드 구조체 정보 확인 방법
```
pwndbg> set print pretty on
pwndbg> p *(v8::internal::compiler::Linkage*)0x55555bb25a40
$2 = {
  <v8::internal::ZoneObject> = {<No data fields>}, 
  members of v8::internal::compiler::Linkage:
  static kJSCallClosureParamIndex = -1,
  static kOsrContextSpillSlotIndex = -1,
  static kOsrAccumulatorRegisterIndex = -1,
  incoming_ = 0x55555bb259c8
}
pwnd
```

특정 메모리의 각 필드가 어떤 역할을 하는지 보려면 직접 해당 메모리 영역을 위와 같이 정적 타입 캐스팅을 한 후 비교해 보는 방법도 있다. 

위의 예시는 특정 함수에서 linkage라는 인자가 주어지는데, 이 인자의 구조체 필드(0x55555bb25a40)에 들어있는 값을 확인하기 위해 찍어 보았다. 

실제로 첫 번째 메모리 주소 필드만 유효했는데, incoming_에 해당하는 주소이다.

## 포인터 별칭 만들기 및 읽기
```
pwndbg> set $link = (v8::internal::compiler::Linkage*)0x55555bb25a40
pwndbg> p $link->incoming_
$3 = (const v8::internal::compiler::CallDescriptor *)0x55555bb259c8
pwndbg> p *(v8::internal::compiler::CallDescriptor*)$3
```

위와 같이 하면 특정 객체 정보를 쉽게 디버깅할 수 있다. 이를테면 (CallDescriptor*)의 flags_ 필드를 보는 방법은 아래와 같다.

```
set $desc = ((v8::internal::compiler::Linkage*)0x55555bb25a40)->incoming_
pwndbg> p ((v8::internal::compiler::CallDescriptor*)$desc)->parameter_count_
pwndbg> p ((v8::internal::compiler::CallDescriptor*)$desc)->flags_
```

## 특정 타입의 상세 구조를 보는 방법
```
ptype v8::internal::compiler::CallDescriptor

type = class v8::internal::compiler::CallDescriptor : public v8::internal::ZoneObject {
  public:
    static const int kFlagsBitsEncodedInInstructionCode;
  private:
    const v8::internal::compiler::CallDescriptor::Kind kind_;
    const v8::internal::CodeEntrypointTag tag_;
    const v8::internal::MachineType target_type_;
    const v8::internal::LinkageLocation target_loc_;
    const v8::internal::LocationSignature * const location_sig_;
    const size_t param_slot_count_;
    const size_t return_slot_count_;
    const v8::internal::compiler::Operator::Properties properties_;
    const v8::internal::RegList callee_saved_registers_;
    const v8::internal::DoubleRegList callee_saved_fp_registers_;
    const v8::internal::RegList allocatable_registers_;
    const Flags flags_;
    const v8::internal::StackArgumentOrder stack_order_;
    const char * const debug_name_;
    uint64_t signature_hash_;
    std::__Cr::optional<unsigned long> gp_param_count_;
    std::__Cr::optional<unsigned long> fp_param_count_;

...생략
```

위와 같은 구조체 정보로 오프셋을 쉽게 구할 수 있다. 

```
pwndbg> p sizeof(v8::internal::compiler::CallDescriptor)
pwndbg> x/32wx $desc
```
로 객체 사이즈를 구한 뒤 크기만큼 메모리를 전체 덤프하여 구조체 필드에 맞춰 오프셋에 대응하는 값을 본다.

```
pwndbg> p $link->incoming_ $7 = (v8::internal::compiler::CallDescriptor * const)0x55555bb259c8
pwndbg> p *(v8::internal::compiler::CallDescriptor * const)0x5555만 보여줄 뿐이다. 
```

또는

```
pwndbg> set $desc = ((v8::internal::compiler::Linkage*)0x55555bb25a40)->incoming_
pwndbg> p *((v8::internal::compiler::CallDescriptor*)$desc)
```

객체의 전체 구조체를 보는 방법은 위와 같다. incoming_ 필드의 포인터 주소에 *로 접근하여 메모리를 확인하면 Calldescriptor에 가지고 있는 필드 내용들이 전부 보이며, V8에서는 이 내용을 Linkage *incoming으로 넘겨 Maglev 그래프를 그리는 정보로 사용한다. (더블체크가 필요한 내용)

## [++ 새벽추가] 
bt 기능 중 한 가지 간과한 점이 있다. bt는 코드의 절차적인 흐름을 보여주진 않는다는 것이다. 아래의 예시 상황을 보자.

#34 0x000055555a173bb3 in v8::internal::compiler::turboshaft::MaglevGraphBuildingPhase::Run (this=<optimized out>, data=0x55555bb459a8, temp_zone=0x55555bb24a00, linkage=0x55555bb25a40) at ../../src/compiler/turboshaft/turbolev-graph-builder.cc:6322

위 라인의 코드는

```
builder.ProcessGraph(maglev_graph);
```

MaglevGraphBuildingPhase::Run 이후에 여러코드가 실행된 후 위 코드의 함수를 호출하게 된다.

#33 0x000055555a173efa in v8::internal::maglev::GraphProcessor<v8::internal::compiler::turboshaft::NodeProcessorBase, true>::ProcessGraph (this=this@entry=0x7fffffffbf88, graph=graph@entry=0x55555bb5ee48) at ../../src/maglev/maglev-graph-processor.h:134

다음 라인인 이 라인의 코드는

```
node_processor_.PreProcessBasicBlock(block);
```

바로 PreProcessBasicBlock을 실행하는 것 같지만 사실 우리는 #34에서 부터 ProcessGraph(maglev_graph); 를 타고 왔으므로 

```
class GraphProcessor {
 public:
  template <typename... Args>
  explicit GraphProcessor(Args&&... args)
      : node_processor_(std::forward<Args>(args)...) {}

  void ProcessGraph(Graph* graph) {
    graph_ = graph;

    node_processor_.PreProcessGraph(graph);

    auto process_constants = [&](auto& map) {
      for (auto it = map.begin(); it != map.end();) {
        ProcessResult result =
            node_processor_.Process(it->second, GetCurrentState());
        switch (result) {
          [[likely]] case ProcessResult::kContinue:
            ++it;
            break;
          case ProcessResult::kRemove:
            it = map.erase(it);
            break;
          case ProcessResult::kHoist:
          case ProcessResult::kAbort:
          case ProcessResult::kSkipBlock:
            UNREACHABLE();
        }
      }
    };
    process_constants(graph->constants());
    process_constants(graph->root());
    process_constants(graph->smi());
    process_constants(graph->tagged_index());
    process_constants(graph->int32());
    process_constants(graph->uint32());
    process_constants(graph->intptr());
    process_constants(graph->float64());
    process_constants(graph->external_references());
    process_constants(graph->trusted_constants());

    for (block_it_ = graph->begin(); block_it_ != graph->end(); ++block_it_) {
      BasicBlock* block = *block_it_;

      BlockProcessResult preprocess_result =
          node_processor_.PreProcessBasicBlock(block);
      switch (preprocess_result) {
        [[likely]] case BlockProcessResult::kContinue:
          break;
        case BlockProcessResult::kSkip:
          continue;
      }

... 생략
```

class GraphProcessor의 void ProcessGraph(Graph* graph) 멤버 함수부터 순서대로 코드를 봐야 한단 거다. 즉, bt의 흐름대로만 분석하려 한다면 중간에 생략 되어있는 코드들의 흐름을 놓치게 된다.


이는 당연한 사실이지만 이 대목에서 유의해야 할 점은 bt는 **이미 리턴된 함수는 출력하지 않음**, **앞서 실행된 코드들은 생략함** 이란 것이다. 
bt는 단순히 스택 프레임을 기준으로 메모리(Stack) 상에서 순차적으로 실행되고 있는 콜스택만을 기준으로 트레이싱하며, 위와 같이 함수가 이미 리턴된 경우나 콜백함수가 있는 등의 중간 과정이 들어있다면 코드를 절차적으로 이해하는데 어려움이 생긴다.

즉, bt의 결과대로만 코드를 이해하려 하면 놓치는 코드가 많다.

