9주차 과제 이후 지속 분석중인데, bt 이후 #36까지는 런타임 매크로를 통해 js 함수 인자를 받고 turbofan까지의 파이프라이닝을 하는 코드라고 유추하였다. (최종적으로 ExcuteJobImpl 매크로로 turboshaft pipeline으로
넘어가고, RUN<turboshaft::MaglevGraphBuildingPhase>(linkage)로 그래프를 그리기 시작(#36)하므로 이 때의 코드부터 정적+동적 분석을 진행한다.(line #35)

우선 linkage가 그래프를 그리기 위해 필요한 데이터를 담은 구조체라고 생각되므로 아래와 같은 방법으로 구조체를 분석한다.

## 메모리 필드 구조체 정보 확인 방법
```
pwndbg> set print pretty on
pwndbg> p *(v8::internal::compiler::Linkage*)0x55555bb25a40
$2 = {
  <v8::internal::ZoneObject> = {<No data fields>}, 
  members of v8::internal::compiler::Linkage:
  static kJSCallClosureParamIndex = -1,
  static kOsrContextSpillSlotIndex = -1,
  static kOsrAccumulatorRegisterIndex = -1,
  incoming_ = 0x55555bb259c8
}
pwnd
```

특정 메모리의 각 필드가 어떤 역할을 하는지보려면 직접 해당 메모리 영역을 위와 같이 정적 타입 캐스팅을 한 후 비교 해보는 방법도 있다. 

위의 예시는 특정 함수에서 linkage라는 인자가 주어지는데, 이 인자의 구조체 필드(0x55555bb25a40)에 들어있는 값을 확인하기 위해 찍어 보았다. 

실제로 첫 번째 메모리 주소 필드만 유효했는데, incoming_에 해당하는 주소이다. 

```
explicit Linkage(CallDescriptor* incoming) : incoming_(incoming) {}
```

참고로 Linkage의 기본 생성자를 보면 incoming은 다음과 같이 CallDescriptor 타입 객체를 가진다. 즉, 우리가 본 구조체 첫번째 필드 incoming(0x55555bb25a40)은 CallDescriptor 타입을 가지는 구조체이다.

## 포인터 별칭 만들기 및 읽기
```
pwndbg> set $link = (v8::internal::compiler::Linkage*)0x55555bb25a40
pwndbg> p $link->incoming_
$3 = (const v8::internal::compiler::CallDescriptor *)0x55555bb259c8
pwndbg> p *(v8::internal::compiler::CallDescriptor*)$3
```

위와 같이 하면 특정 객체 정보를 쉽게 디버깅 할 수 있다. 이를테면 (CallDescriptor*)의 flags_ 필드를 보는 방법은 아래와 같다.

```
set $desc = ((v8::internal::compiler::Linkage*)0x55555bb25a40)->incoming_
pwndbg> p ((v8::internal::compiler::CallDescriptor*)$desc)->parameter_count_
pwndbg> p ((v8::internal::compiler::CallDescriptor*)$desc)->flags_
```


## 특정 타입의 상세 구조를 보는 방법
```
ptype v8::internal::compiler::CallDescriptor

type = class v8::internal::compiler::CallDescriptor : public v8::internal::ZoneObject {
  public:
    static const int kFlagsBitsEncodedInInstructionCode;
  private:
    const v8::internal::compiler::CallDescriptor::Kind kind_;
    const v8::internal::CodeEntrypointTag tag_;
    const v8::internal::MachineType target_type_;
    const v8::internal::LinkageLocation target_loc_;
    const v8::internal::LocationSignature * const location_sig_;
    const size_t param_slot_count_;
    const size_t return_slot_count_;
    const v8::internal::compiler::Operator::Properties properties_;
    const v8::internal::RegList callee_saved_registers_;
    const v8::internal::DoubleRegList callee_saved_fp_registers_;
    const v8::internal::RegList allocatable_registers_;
    const Flags flags_;
    const v8::internal::StackArgumentOrder stack_order_;
    const char * const debug_name_;
    uint64_t signature_hash_;
    std::__Cr::optional<unsigned long> gp_param_count_;
    std::__Cr::optional<unsigned long> fp_param_count_;

...생략
```

위와 같은 구조체 정보로 오프셋을 쉽게 구할 수 있다. 

```
pwndbg> p sizeof(v8::internal::compiler::CallDescriptor)
pwndbg> x/32wx $desc
```
로 객체 사이즈를 구한 뒤 크기만큼 메모리를 전체 덤프 하여 구조체 필드에 맞춰 오프셋에 대응하는 값을 본다.


```
pwndbg> p $link->incoming_ $7 = (v8::internal::compiler::CallDescriptor * const) 0x55555bb259c8
pwndbg> p *(v8::internal::compiler::CallDescriptor * const)0x5555만 보여줄 뿐이다. 



