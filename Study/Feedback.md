## 1주차
1. 처음 접한 타깃이 무엇이든 이슈가 발생되었을때 그것을 기록하고 정리해둬야한다.
2. 이슈컨트롤에 약하다. (우선순위를 잘 파악했어야했다.) 즉, 해당 취약점이 발생한 컴포넌트 및 발생 기전을 개략적으로 파악하는 것을 중점으로 뒀어야 했다.
3. 결과를 먼저 작성하고 그 다음 과정을 적었어야 했다.
4. 가장 중요했던건 취약점 분석을 먼저 결과로 적었어야했다.
5. 깃 레포지터리에 글을 넣을떄 언더바를 넣어야한다. (정리와 효율이 중요)
6. 폴더 정리가 중요했다.
7. 코드의 기능을 이해하는 것이 추상적이다. 시각화 과제를 통해 코드를 잘 이해 했느냐가 중요했다.
8. 작은 코드 단위(함수 등)에서 디테일을 살려나가야 한다.
9. 크로스 레퍼런스, 콜 상호작용 등을 이해하려면 https://source.chromium.org/chromium/chromium/src/+/main:v8/ 이걸 활용
10. 독시젠은 커밋별(주석을 달면서)로 모든걸 볼 수 있는 강력한 도구
11. C++ 영문서를 보며 공부할것
12. V8 분석 할 때 C++ 퍼블릭 네임스페이스와 클래스를 기준으로 본다.
13. 다음 과제는 첫 과제의 두번 째 목표(취약점 발생 기전)를 이행해볼것

## 2주차
1. 결과가 이상한 문장이다. 결론적으로 코드 이해가 덜 되었다가 된다.
2. 얕게나마라고 쓰지말고 모르는것과 아는걸 분명히 해야한다. (뭘 봤고 뭘 이해했고 뭘 알게되었다를 명확하게)
3. 공개된 커밋 정보를 하나라도 놓치면 절대 안된다. (이런 실수를 절대 하면 안된다.) 공개된 정보를 활용하지않는건 큰 잘못이다. (regress = 폐기버그를 방지하기위해 v8은 코드를 넣는다.)
4. 이 PoC가 왜 트리거 되는지를 이해해야한다.
5. 다음주 목표는 취약점의 발생 기전을 명확하게 알아와야한다.

## 3주차 
내장 함수 레퍼런스로 좋은 사이트: CodeStubAssembler builtins · V8
1. Postmortem(부검) = 이미 발생한 취약점과 PoC를 들고 원데이 분석을 하는 것, 지금의 보고서에는 regress를 기반해서 취약점은 맞게 풀어냈지만, 그래서 왜 취약하고 어떻게 패치를 해야하느냐에대한 분석이 없다. 최종적으로는 어떤 익스플로잇이 이루어질 수 있는지는 분석이 안되어있고 너무 알려진 것에 대한 Porstmortem만 진행되었다.
2. 전반적으로 취약점을 추상적으로 이해하고 있다.
3. 선택지 1. 디버깅을 직접 해보면서 True/False 변하는 과정을 보는것.
선택지 2. 새로운 케이스를 보는것. (선생님께선 이것을 추천)
4. 앞으로 한 두 개 케이스 정도는 Postmortem(부검)이 괜찮다. 그러나 4~5개부터는 이게 좋지않다.
5. 보고서 포맷이 여전히 미괄이다. (그래서 왜 취약함?이 안보인다. -> 이런 일이 일어나는건 알겠다 근데 이게 왜 취약한거야?, 타입 컨퓨전으로 인해 어떤 버그가 일어나는지에 대해서 안적혀있다.)
6. 현재 분석했던건 V8 샌드박스 없이 익스가 가능한 취약점.
7. V8에서 찾은 취약점이라고 무조건 CVE가 나오는 것이 아니다. (스테이블 채널에서 찾고 스테이블 트리로 병합이 되어야한다.)
8. 4주차 과제는 메인 패치가 있고, 혹시 모를 비슷한 부류의 취약점을 잡을 어썰션을 추가한 패치 두 개가 있다.
(이것도 Postmertem해도 괜찮다.)
9. 할 수 있는걸 다 해봐라 (단, 첫 번째는 소스트레일과 독시젠을 활용을 해야한다.)
10. 3주차 보고서가 확실히 1,2주차보단 확실히 나았다.
11. 버그헌팅 타겟을 고를때 12,13,14를 참고
12. 친숙한 타겟을 고를것
13. 1번이 안되면 임팩트있는 타겟을 고를 것
14. 중요하고 어려운 타겟이여야한다. ( = 이걸 했을때 임팩트가 무조건 보장된다, 밸류에이션이 쉽다.)
15. 하드닝 바이패스 트릭이 존재하는 취약점이 있긴하다. (온몸비틀기를 해서 하는 경우)
16. 지피티보단 NotebookLM을 최대한 활용할것. (지피티를 쓸 땐 할루시네이션을 구분 할 수 있어야한다.)
17. 취약점 발생 기전을 이해하는가부터 시작해야한다.
18. 구성 로직 자체에 취약점이 있다. (두 개의 JIT 컴파일러에서 발생되는데 둘 구조가 아예 다르다.)
19. Postmertem을 할 때 환경 구축 후 Regress를 실행해보면서 디버그 프린트를 찍으며 따라가보는게 좋을것.
20. 내용이 적어도 되지만, 오개념없이 명확하게 설명이 될 수 있어야한다. (네이티브 코드 분석이 정말 중요하다.)
-> 디자인 문서(소스 트레일)를 정확하게 이해하고 백그라운드를 하나하나 보면서 각 컴파일러 기능과 내부 구조를 이해해야한다. 아주 명확하게 설명이 되어야한다.
21. 최대한 많은 JIT 컴파일러에 대해 이해를 해나가는게 중요.
22. 이번엔 maglev, turboshaft의 내부구조 컴포넌트에대한 이해가 우선되면 좋음.
(3주차까진 백그라운드만 보게 될 수도 있다. -> 이슈컨트롤을 컴포넌트에대한 이해를 하는것을 중점적으로.)

최종적으로, V8 티어링 시스템, 인터페이스에 중점을 맞추는 것으로 해본다.

* 원본 보고 참조는 절대 안된다.(다른 사람 케이스스터디, 오리진 레포트 등 절대 금지)

## 4주차
https://chromium-review.googlesource.com/c/v8/v8/+/6573553

https://chromium-review.googlesource.com/c/v8/v8/+/6578316

https://x.com/xvonfers/status/1884313859248513354

https://notebooklm.google/

## 5주차 

## 6주차 
1. 코드를 잘 이해한건지 모르겠다. 절대 turbo-lev부터 보면 안된다 maglev를 보고 터보세프트를 봐야 turbolev를 이해할 수 있다.
2. 라인 바이 라인으로 하나하나 정확히 짚고 넘어가야한다. (추상적인 수준에서 하면 절대 안된다.)
3. 라인 바이 라인을 완벽히 보면 이 함수가 어떤 인풋과 아웃풋이 들어가서 어떤 기능들을 수행하는지 알 수 있다.
4. catch_block이 무엇인지 더 깊이 갔어야 한다. 
5. 버츄얼 누산기가 어떤건지 ? 우리가 인터프리터에서 봤던건지 ? 이런 세세한거 하나하나를 다 봤어야한다.
6. 한 줄을 보더라도 깊게 봐야한다.
7. 아직 이해하지 못하였음 이런게 나오면 안된다.
8. CS를 하였을 때 하지 말아야 할 것 : 제대로 이해하지 않는 것, (컨테이너 타입?) 와 같은것과 유추와 같은 것들. 문장을 한 줄을 쓰더라도 사실인 것만 적어야 한다.
9. BasicBlock에 어떤 객체가 들어갔었는지를 정확히 이해했어야 한다.
10. 함수를 볼 때 인풋이 뭔지 모르는데 로직을 파악할 수가 없다.
11. 이해라는건 인풋, 로직 그리고 아웃풋의 결합이다.
12. C++ 실력이 좋지않은 상황에서 해도해도 안되면 선생님께 디스커션을 드리는 방법도 있다.
13. 인풋을 파악할때 문법적인 문제에서 막히는건 중요한 문제이므로 선생님께 물어봐야할것
14. 코드를 보는 시간에대한 투자를 늘려야한다.
15. 인풋 로직 아웃풋 중에 하나라도 골라가야한다. (한번에 다 먹으려고하면안된다.)
16. 왜 maglev에서 베이직 블럭인지 같은 상세한 것들을 이해해야한다.

다음주는 인풋 두 개를 제대로 잡고 해오는걸 목표로 할 것.

## 7주차 
1. 이대로 가면 양이 매우 방대해진다. 
2. regress.js 넣고 환경 구축하면서 취약점 트리거를 찾아야 하기로 했다. 
3. 디버깅을 하려면 regress.js를 넣고 크래시가 나면 어디를 봐야 한다가 명확해진다.
4. 취약점 분석은 사막에서 바늘 찾기와 같다. 그 사막의 크기를 어떻게 효과적으로 줄여나가야할지가 중요하다.
5. 다음 주부터는 regress.js를 넣고 backtrace를 들고 디버깅 해볼 것.
6. AssertEqual 같은건 빼고 디버깅을 해볼 것. (regress.js를 그대로 돌리면 실행이 안될건데 알아서 잘 해결해볼 것)
7. 아 디버깅을 할 땐 백트레이스 상 으론 마그레브가 안보이고 콜백으로 이미 터보셰프트를 타고올 것.
8. https://source.chromium.org/chromium/chromium/src/+/main:v8/src/runtime/runtime-compiler.cc;drc=2c073a142ee5bcd6418f76c359be2f73fd479857;l=224
를 분석 해볼 것. RUNTIME_FUNCTION(Runtime_OptimizeTurbofanEager)
9. 어떤 상황에서 maglev가 unable이 되는가? 를 생각해보면서 8번 함수를 보는 것.
10. 취약점은 루트커즈에서부터 더 멀리가서 터보셰프트에서 터진다.
11. 구문 분석 어휘 분석은 이미 이그니션에서 다 끝난다.
12. 커밋 트래킹을 안하고 원데이만 보면 어느 시대의 시점에 따라 달라지는 얘기가 나올 수 있다.
13. 다음 주는 크래시를 발생시켜서 백트레이스를 뽑는걸 목표로 해야할 것.
14. test 262 → https://github.com/tc39/test262
15. test 262를 사용하지 않고 크래시를 내게 해야 한다.

취약한 환경 구축 → PoC를 만들어서 크래시를 내고 → 백트레이스를 내서 개략적인 이해를 해보는 것.

## 8주차
1. BT 결과 출력을 안하였다.
2. 타이틀을 심플하게 한건 좋았다.
3. 문제가 되는 백트레이스 라인을 찍었어야 했다.
4. v8 할 땐 폰 디버거가 좋은데 폰 디버거가 심볼과 연동이 잘 된다.
5. https://chromium.googlesource.com/v8/v8/+/refs/heads/main/tools/gdbinit

이걸 사용하면 v8 전용 gdb 플러그인을 쓸 수 있으며, 편리한 기능들이 많다.

1. 이슈 사항이 발생했을때 바로 말씀드릴 것(만약 컴파일러를 만들게 되었으면, 그걸 해보겠다 같은걸 최대한 빨리 말씀드리는게 좋다.  선생님이 생각하시는 기대치가 있으므로..
2. MIT Openbooks 컴파일러 이론을 통해 더 최적화된 기술의 컴파일러 개발 기술을 공부해보는 것도 좋다. (Computation Structure part)

https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/pages/c11/

번역 안된 해외 컴파일러 서적에도 심화적인 내용들이 많다. → 번역본이 있긴한데 많이 구버전이다. 

(Compilers: Principles, Techniques, & Tools)

LLVM docs(https://llvm.org/docs/) 로 컴파일러 공부하는것도 좋다. (번역기를 돌려가며) → llvm과는 맥락이 좀 다르다. v8은 다이나믹 → llvm은 스태틱 파일(이 스태틱과 다이나믹의 어프로치 차이가 많이 다르다. → 이게 좀 더 편함)

예로들어 c++로 c++컴파일러를 만드는건 쉬운데, c++로 js 컴파일러 만들긴 굉장히 어려워진다.

1. 원래 지금은 컴파일러가 할만하고 이제 싫어질 정도로 봐야 한다..
2. 되도록이면 컴파일러를 볼 때 어지간하면 이론을 배울 땐 직접 구현을 해보거나, 이미 잘 구현된 걸 이해해보거나 해야 한다.
3. 본격적으로 컴파일러 백엔드로 들어가기 전까지는 굉장히 추상적으로 이해하기 쉽지만 막상 이걸 직접 구현하긴 어렵다. 
4. 컴파일러를 가볍게 만드는걸로 그치지 말고 더 심화적인 구현을 배워야하는데 이걸 이미 구현된 코드를 보는게 좋다.
5. https://github.com/rui314/chibicc 이건 굉장히 단순하면서도 아름다운 코드. (고차원적지만 기본적으로 가지고 있는걸 다 가지고있다.)
6. 문제를 크게 보지말고 작게 봐야한다. (V8은 어차피 바이너리다. 이게 엄청 난 게 아니다.)
7. 진도를 나가는 속도에 있어서 지금 굳이 신경을 써야 하나 싶기도 하고, 지금 굳이 컴파일러를 봐야 하는가 싶기도 하다.  (탑다운으로 내리 꽂으면 이걸 굳이 먼저 해야 하나?)
8. V8을 보는 시간을 지금보다 많이 사용해야 한다.
9. 내가 이번 주에 뭘 해야했다가 아니라 discussion 할 포인트를 찾아야 한다. (많이 고민 해보는게 필요하다. 좀 더 올바른 방향으로 고민해야 한다.)
10. 다음 주부터는 시간을 많이 투자할 것 (70시간 이상은 넣어보기 전체 70시간 중에 60시간은 아무것도 못할 수도 있다.)
11. 선생님은 아카데믹한 교육을 해보는 걸 계속 하고싶어하신다.
12. 바텀업은 시간을 많이 가져야한다. 하지만 이건 시간 빌게이츠 → 직장인에게는 굉장히 어렵다. (Xion님은 바텀업을 극단적으로 잘한 케이스다.)
13. 탑다운이 좋은 점은 뭘 해야 하는지 목표가 분명하고, 이걸 위해서 필요한게 분명해지고 테스크가 쪼개진다.
14. 전체적인 개괄을 보면 그때부턴 변화를 따라가는 게 쉽다. 
15. V8의 개괄을 볼 때 적어도 원데이 취약점이 어떻게 작용되는진 알아야 한다. (적어도 입력 출력 로직, 그리고 그 로직이 될 수 밖에 없는 이유를 알아야한다)
16. 지금 단계에선 코드를 좀 더 보는 게 좋다. (백트레이스가 뽑히면 파일이랑 라인 넘버가 나오는데 이걸 기반으로 코드를 보는 게 좋다 이 라인이 어떤 인풋과 아웃풋, 로직을 보는게 좋다.)
17. 원데이에서 왜 디버깅을 해야할까 ?(이 이유를 알아오는 게 과제 → 또는 하지 않아도 되는 이유?)
18. https://mermaid.js.org/ 코드 이해를 하는게 어려울떄 이걸 쓰는게 좋다. (OOP 특성상 저수준으로 내려가면 모든 광활한걸 다 보아라 → 모르는걸 다 보면 모르는게 없어진다.)
19. 탑다운 → 대충대충 조금씩 보더라도 나아가야 한다. (이건 절대적으로 투자하는 시간 대비로 형성된다.)
20. 다음주 코드분석은 PoC 몇번 째 라인이 실행될 때 V8의 어떤 코드가 실행되고 이 코드는 무엇인지 알아오기, PoC 라인의 문장을 V8의 흐름 안에서 어떻게 흘러가는지 보는 것.
21. 디버깅은 디버거가 있어야 하는 게 아니다. (그냥 라인마다 시스템 브레이크를 찍어도 되는거고 디버그 프린트를 찍어도 되는 거고 그냥 어떻게든 코드를 이해하면 되는게 디버그다.)

https://github.com/rui314/chibicc - 컴파일 코드 분석해보기

## 9주차
넓게는 이 PoC가 인터널에서 어떻게 작동하는질 알아야 하는데, 아래 세가지 과정으로 나눠서 점진적으로 봐야한다.

1. 가장 첫 엔트리 포인트로 PoC가 어떻게 동작하는질 알려고 노력해야 한다. (JS 수준에서 어떻게 동작하는질 아주 잘 봐야 한다.) → 최적화가 되었을 때 어떻게 최적화가 되는지 생각을 해봐야 한다.(정적인 레벨에서 이걸 이해할 수 있으면 잘하게 된다.) , DCE나 BCE(바운드체크, 데드코드 엘리미네이션) 등을 이해해야 한다. → 최적화 되지 않았을 때와 최적화 된 후(상수폴딩 등)의 차이를 인지해야 한다. → 지금은 어려울 수 있어도 나중엔 PoC만 봐도 코드가 어떻게 작동하는지 볼 수 있다.

- 사실 이건 CS의 근본이 다 채워져야 가능하다.

1. 백트레이스를 뽑아보면 나오는 출력값(파일명, 괄호 등)의 의미를 알아야 한다.
2. 백트레이스에 찍히는 각 함수들의 동작 이해를 해야 한다.

문제를 크게 만들지 말고 쪼개서 접근해야 한다. → 작은 단위에서 부터 점진적으로

페이커의 어록: 슈퍼플레이를 하기위한 3가지 원칙

1. 해야된다면해라
2. 하지말아야한다면 하지마라
3. 할까말까 고민된다면 해라 

Turbolev의 이번 PoC는 None 캐스팅 타입이라 문제가 발생된다.(일반적인 타입 컨퓨전은 아님) → 일반적인 타입 컨퓨전은 캐스팅 되지 말아야 할게 캐스팅 되어서 일어난다.  

타입 컨퓨전 기본 - 

차일드 클래스가 패런츠 클래스로 캐스팅되면 업캐스팅(대부분 문제가 잘 안댐)

패런츠 클래스가 차일드 클래스도 캐스팅 되면 다운캐스팅(이 경우에 문제가 많이 발생)

드림핵에 EXP NAN 한번 볼 것 (타입 컨퓨전에 대한 이해가 많이 없다..)

가장 큰 본인의 문제는 C++에서의 버그 클래스를 잘 이해하지 못한다. 추가적으로 V8 도메인 지식도 부족. 


V8 취약점 슬라이드를 많이 보는 것도 좋다. (초보자들은 기존 연구 자료(어프로치 등)와 논문에 대해 굉장히 소홀하다.)  → 시간을 내서 V8 자료들을 취미 삼아 읽어보면 좋다. (V8 제로콘 등)  

* 수업에 관련한 라이트업은 안나오므로 걱정 x

PS. 앞으로 모든걸 깃허브로 관리할 예정 

강의 자료 → 18일 에서 주 후반부(강의 시작 3~4일 전)
