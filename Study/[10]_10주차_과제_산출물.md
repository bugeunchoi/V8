## 분석 결과

%OptimizeFunctionOnNextCall()에 의해 JS에서 Turbofan까지 Bulitin Turbofan이 실행되는 과정을 분석하였음.

## 분석

```
RUNTIME_FUNCTION(Runtime_OptimizeTurbofanEager) {
  HandleScope scope(isolate);
  DCHECK_EQ(1, args.length());
  DirectHandle<JSFunction> function = args.at<JSFunction>(0);
  DCHECK(function->IsOptimizationRequested(isolate));
  CompileOptimized(function, ConcurrencyMode::kSynchronous,
                   CodeKind::TURBOFAN_JS, isolate);
  return ReadOnlyRoots(isolate).undefined_value();
}
```

Builtins_OptimizeTurbofanEager()를 부르면 RUNTIME_FUNCTION() 매크로에 의해 래핑된 함수가 호출된다.

```
#define RUNTIME_FUNCTION(Name)                           \
  RUNTIME_FUNCTION_RETURNS_TYPE(Address, Tagged<Object>, \
                                BUILTIN_CONVERT_RESULT, Name)
```

RUNTIME_FUNCTION은 다음과 같이 래핑되어 있으며, Name을 인자로 다시 RUNTIME_FUNCTION_RETURNS_TYPE()을 만든다. 이 경우
RUNTIME_FUNCTION_RETURNS_TYPE(인자1, 인자2, 인자3, OptimizeTurboFanEager)가 된다.

```
#define RUNTIME_FUNCTION_RETURNS_TYPE(Type, InternalType, Convert, Name)   \
  static V8_INLINE InternalType __RT_impl_##Name(RuntimeArguments args,    \
                                                 Isolate* isolate);        \
  RUNTIME_ENTRY_WITH_RCS(Type, InternalType, Convert, Name)                \
  Type Name(int args_length, Address* args_object, Isolate* isolate) {     \
    DCHECK(isolate->context().is_null() || IsContext(isolate->context())); \
    DCHECK(isolate->IsOnCentralStack());                                   \
    CLOBBER_DOUBLE_REGISTERS();                                            \
    TEST_AND_CALL_RCS(Name)                                                \
    RuntimeArguments args(args_length, args_object);                       \
    if constexpr (detail::RuntimeFunctionFullNameCanTriggerGC(             \
                      detail::RuntimeFunctionFullName::k##Name)) {         \
      return Convert(__RT_impl_##Name(args, isolate));                     \
    } else {                                                               \
      DisallowGarbageCollection no_gc;                                     \
      return Convert(__RT_impl_##Name(args, isolate));                     \
    }                                                                      \
  }                                
```

RUNTIME_FUNCTION_RETURNS_TYPE()로 내부 호출이 되면 Name은 static 함수로서 __RT_impl_##Name(RuntimeArguments args,
\ Isolate* isolate);  로 재정의 되는데, 이 때 인자들은 RuntimeArguments args로 묶인다. 리턴 된 위 함수는 본 페이지 첫 코드에서
보았던 내부 구현 코드가 실행되고 이 때 인자로 묶인 args는 

```
DirectHandle<JSFunction> function = args.at<JSFunction>(0);
```

위와 같이 이후 function 정보를 핸들링 할 때 사용된다.

그 다음 CompileOptimized(function, mode, target_kind, isolate)가 실행가며, 이 때 target_kind가 어느 컴파일러로 옵티마이즈를 
할 지 정한다. 

오버라이딩 규칙에 따라 인자가 같은 인근의 함수 구현체를 찾게 되는데, 이는 아래 코드다.

```
namespace {

void CompileOptimized(DirectHandle<JSFunction> function, ConcurrencyMode mode,
                      CodeKind target_kind, Isolate* isolate) {
  // Ensure that the tiering request is reset even if compilation fails.
  function->ResetTieringRequests();

  // As a pre- and post-condition of CompileOptimized, the function *must* be
  // compiled, i.e. the installed InstructionStream object must not be
  // CompileLazy.
  IsCompiledScope is_compiled_scope(function->shared(), isolate);
  if (V8_UNLIKELY(!is_compiled_scope.is_compiled())) {
    // This happens if the code is flushed while we still have an optimization
    // request pending (or if manually an optimization is requested on an
    // uncompiled function).
    // Instead of calling into Compiler::Compile and having to do exception
    // handling here, we reset and return and thus tail-call into CompileLazy.
    function->ResetIfCodeFlushed(isolate);
    return;
  }

  if (mode == ConcurrencyMode::kConcurrent) {
    // No need to start another compile job.
    // Also, various fuzzing flags like --always-turbofan might already compile
    // this function in the above Compiler::Compile function.
    if (function->tiering_in_progress() ||
        function->GetActiveTier(isolate) >= target_kind) {
      static_assert(kTieringStateInProgressBlocksTierup);
      function->SetInterruptBudget(isolate, BudgetModification::kRaise);
      return;
    }
  }

...

ompiler::CompileOptimized(isolate, function, mode, target_kind);
```

본 코드는 function, mode, target_kind, isolate로 구현되어 있으며 namespace로 작용한다. 만약 코드가 컴파일 되어 있지않고 모드가 kConcurrent가 아니라면 
Compiler::CompileOptimized(isolate, function, mode, target_kind); 를 실행하게 되는데,
이 네임스페이스 위 코드를 보면 namespace v8::internal로 감싸져 있어 v8::internal::Compiler::CompileOptimized(isolate, function, mode, target_kind)를 찾아 실행하게 된다.

본 네임스페이스 코드는 ../../src/codegen/compiler.cc에 있으며 

```
void Compiler::CompileOptimized(Isolate* isolate,
                                DirectHandle<JSFunction> function,
                                ConcurrencyMode mode, CodeKind code_kind) {
  function->TraceOptimizationStatus("^%s", CodeKindToString(code_kind));
  DCHECK(CodeKindIsOptimizedJSFunction(code_kind));
  DCHECK(AllowCompilation::IsAllowed(isolate));

  if (v8_flags.stress_concurrent_inlining &&
      isolate->concurrent_recompilation_enabled() && IsSynchronous(mode) &&
      isolate->node_observer() == nullptr) {
    SpawnDuplicateConcurrentJobForStressTesting(isolate, function, mode,
                                                code_kind);
  }

#ifdef DEBUG
  if (V8_ENABLE_LEAPTIERING_BOOL && mode == ConcurrencyMode::kConcurrent) {
    DCHECK_IMPLIES(code_kind == CodeKind::MAGLEV,
                   !function->ActiveTierIsMaglev(isolate));
    DCHECK_IMPLIES(code_kind == CodeKind::TURBOFAN_JS,
                   !function->ActiveTierIsTurbofan(isolate));
  }
  bool tiering_was_in_progress = function->tiering_in_progress();
  DCHECK_IMPLIES(tiering_was_in_progress, mode != ConcurrencyMode::kConcurrent);
#endif  // DEBUG

  DirectHandle<Code> code;
  if (GetOrCompileOptimized(isolate, function, mode, code_kind)
          .ToHandle(&code)) {
    function->UpdateOptimizedCode(isolate, *code);
    DCHECK_IMPLIES(v8_flags.log_function_events,
                   function->IsLoggingRequested(isolate));
  } else {
#ifdef V8_ENABLE_LEAPTIERING
    // We can get here from CompileLazy when we have requested optimized code
    // which isn't yet ready. Without Leaptiering, we'll already have set the
    // function's code to the bytecode/baseline code on the SFI. However, in the
    // leaptiering case, we potentially need to do this now.
    if (!function->is_compiled(isolate)) {
      function->UpdateCodeKeepTieringRequests(
          isolate, function->shared()->GetCode(isolate));
    }
#endif  // V8_ENABLE_LEAPTIERING
  }

#ifdef DEBUG
  DCHECK(!isolate->has_exception());
  DCHECK(function->is_compiled(isolate));
  DCHECK(function->shared()->HasBytecodeArray());

  DCHECK_IMPLIES(function->IsTieringRequestedOrInProgress() &&
                     !function->IsLoggingRequested(isolate),
                 function->tiering_in_progress());
  if (!v8_flags.always_turbofan) {
    // Before a maglev optimization job is started we might have to compile
    // bytecode. This can trigger a turbofan compilation if always_turbofan is
    // set. Therefore we need to skip this dcheck in that case.
    DCHECK_IMPLIES(!tiering_was_in_progress && function->tiering_in_progress(),
                   function->ChecksTieringState(isolate));
  }
  DCHECK_IMPLIES(!tiering_was_in_progress && function->tiering_in_progress(),
                 IsConcurrent(mode));
#endif  // DEBUG
```

위와 같이 구현되어 있다. 이 때 mode가 kSynchronous므로 

```
  if (GetOrCompileOptimized(isolate, function, mode, code_kind)
          .ToHandle(&code))
```


위의 조건이 실행되는데 GetOrCompileOptimized()는 아래와 같이 같은 소스 파일에 구현되어 있다.

```
aybeHandle<Code> GetOrCompileOptimized(
    Isolate* isolate, DirectHandle<JSFunction> function, ConcurrencyMode mode,
    CodeKind code_kind, BytecodeOffset osr_offset = BytecodeOffset::None(),
    CompileResultBehavior result_behavior = CompileResultBehavior::kDefault) {
  if (IsOSR(osr_offset)) {
    function->TraceOptimizationStatus(
        "^%s (osr %i)", CodeKindToString(code_kind), osr_offset.ToInt());
  } else {
    function->TraceOptimizationStatus("^%s", CodeKindToString(code_kind));
  }
  DCHECK(CodeKindIsOptimizedJSFunction(code_kind));

  DirectHandle<SharedFunctionInfo> shared(function->shared(), isolate);

  // Reset the OSR urgency. If we enter a function OSR should not be triggered.
  // If we are in fact in a loop we should avoid triggering this compilation
  // request on every iteration and thereby skipping other interrupts.
  function->feedback_vector()->reset_osr_urgency();

  // Clear the optimization marker on the function so that we don't try to
  // re-optimize.
  if (!IsOSR(osr_offset)) {
    function->ResetTieringRequests();
    // Always reset the OSR urgency to ensure we reset it on function entry.
    int invocation_count =
        function->feedback_vector()->invocation_count(kRelaxedLoad);
    if (!(V8_UNLIKELY(v8_flags.testing_d8_test_runner ||
                      v8_flags.allow_natives_syntax) &&
          ManualOptimizationTable::IsMarkedForManualOptimization(isolate,
                                                                 *function)) &&
        invocation_count < v8_flags.minimum_invocations_before_optimization) {
      function->feedback_vector()->set_invocation_count(invocation_count + 1,
                                                        kRelaxedStore);
      return {};
    }
  }

  // TODO(v8:7700): Distinguish between Maglev and Turbofan.
  if (shared->optimization_disabled() &&
      shared->disabled_optimization_reason() == BailoutReason::kNeverOptimize) {
    return {};
  }

  // Do not optimize when debugger needs to hook into every call.
  if (isolate->debug()->needs_check_on_function_call()) {
    return {};
  }

  // Do not optimize if we need to be able to set break points.
  if (shared->HasBreakInfo(isolate)) return {};

  // Do not optimize if optimization is disabled or function doesn't pass
  // turbo_filter.
  if (!ShouldOptimize(code_kind, shared)) return {};

  if (!V8_ENABLE_LEAPTIERING_BOOL || IsOSR(osr_offset)) {
    Handle<Code> cached_code;
    if (OptimizedCodeCache::Get(isolate, function, osr_offset, code_kind)
            .ToHandle(&cached_code)) {
      DCHECK_IMPLIES(!IsOSR(osr_offset), cached_code->kind() <= code_kind);
      return cached_code;
    }

    if (IsOSR(osr_offset)) {
      // One OSR job per function at a time.
      if (function->osr_tiering_in_progress()) return {};
    }
  }

  DCHECK(shared->is_compiled());

  if (code_kind == CodeKind::TURBOFAN_JS) {
    return CompileTurbofan(isolate, indirect_handle(function, isolate), shared,
                           mode, osr_offset, result_behavior);
  } else {
    DCHECK_EQ(code_kind, CodeKind::MAGLEV);
    return CompileMaglev(isolate, indirect_handle(function, isolate), mode,
                         osr_offset, result_behavior);
  }
}
```

위 코드에서 만약 codekind가 TURBOFAN_JS라면 아래와 같이 리턴된다.

```
 if (code_kind == CodeKind::TURBOFAN_JS) {
    return CompileTurbofan(isolate, indirect_handle(function, isolate), shared,
                           mode, osr_offset, result_behavior);
```

CompileTurbofan()도 같은 소스코드 파일 내에 위치하며 아래와 같이 구현되어 있다.

```
MaybeHandle<Code> CompileTurbofan(Isolate* isolate, Handle<JSFunction> function,
                                  DirectHandle<SharedFunctionInfo> shared,
                                  ConcurrencyMode mode,
                                  BytecodeOffset osr_offset,
                                  CompileResultBehavior result_behavior) {
  VMState<COMPILER> state(isolate);
  TimerEventScope<TimerEventOptimizeCode> optimize_code_timer(isolate);
  RCS_SCOPE(isolate, RuntimeCallCounterId::kOptimizeCode);
  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"), "V8.OptimizeCode");

  DCHECK(!isolate->has_exception());
  PostponeInterruptsScope postpone(isolate);
  const compiler::IsScriptAvailable has_script =
      IsScript(shared->script()) ? compiler::IsScriptAvailable::kYes
                                 : compiler::IsScriptAvailable::kNo;
  // BUG(5946): This DCHECK is necessary to make certain that we won't
  // tolerate the lack of a script without bytecode.
  DCHECK_IMPLIES(has_script == compiler::IsScriptAvailable::kNo,
                 shared->HasBytecodeArray());
  std::unique_ptr<TurbofanCompilationJob> job(
      compiler::NewCompilationJob(isolate, function, has_script, osr_offset));

  if (result_behavior == CompileResultBehavior::kDiscardForTesting) {
    job->compilation_info()->set_discard_result_for_testing();
  }

  if (IsOSR(osr_offset)) {
    isolate->CountUsage(v8::Isolate::kTurboFanOsrCompileStarted);
  }

  // Prepare the job and launch concurrent compilation, or compile now.
  if (IsConcurrent(mode)) {
    if (CompileTurbofan_Concurrent(isolate, std::move(job))) return {};
  } else {
    DCHECK(IsSynchronous(mode));
    if (CompileTurbofan_NotConcurrent(isolate, job.get())) {
      return job->compilation_info()->code();
    }
  }

  if (isolate->has_exception()) isolate->clear_exception();
  return {};
}
```

위 코드에서 if(IsConcurrent(mode))에 mode가 설정되어 있다면, CompileTurbofan_NotConcurrent()가 실행된다. 

```
bool CompileTurbofan_NotConcurrent(Isolate* isolate,
                                   TurbofanCompilationJob* job) {
  OptimizedCompilationInfo* const compilation_info = job->compilation_info();
  DCHECK_EQ(compilation_info->code_kind(), CodeKind::TURBOFAN_JS);

  TimerEventScope<TimerEventRecompileSynchronous> timer(isolate);
  RCS_SCOPE(isolate, RuntimeCallCounterId::kOptimizeSynchronous);
  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"),
               "V8.OptimizeNonConcurrent");

  if (!PrepareJobWithHandleScope(job, isolate, compilation_info,
                                 ConcurrencyMode::kSynchronous)) {
    CompilerTracer::TraceAbortedJob(isolate, compilation_info,
                                    job->prepare_in_ms(), job->execute_in_ms(),
                                    job->finalize_in_ms());
    return false;
  }

  if (job->ExecuteJob(isolate->counters()->runtime_call_stats(),
                      isolate->main_thread_local_isolate())) {
    CompilerTracer::TraceAbortedJob(isolate, compilation_info,
                                    job->prepare_in_ms(), job->execute_in_ms(),
                                    job->finalize_in_ms());
    return false;
  }

  if (job->FinalizeJob(isolate) != CompilationJob::SUCCEEDED) {
    CompilerTracer::TraceAbortedJob(isolate, compilation_info,
                                    job->prepare_in_ms(), job->execute_in_ms(),
                                    job->finalize_in_ms());
    return false;
  }

  // Success!
  job->RecordCompilationStats(ConcurrencyMode::kSynchronous, isolate);
  DCHECK(!isolate->has_exception());
  if (!V8_ENABLE_LEAPTIERING_BOOL || job->compilation_info()->is_osr()) {
    OptimizedCodeCache::Insert(
        isolate, *compilation_info->closure(), compilation_info->osr_offset(),
        *compilation_info->code(),
        compilation_info->function_context_specializing());
  }
  job->RecordFunctionCompilation(LogEventListener::CodeTag::kFunction, isolate);
  return true;
}
```



