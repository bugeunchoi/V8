## JS 분석
---
```
//gn gen out.gn/x64.debug --args='is_debug=true is_component_build=false symbol_level=2'
//Flags: --allow-natives-syntax --turbolev

function bar(i) {
          if (i == 5) { ThrowSomething(); }
}

function foo(x) {
          let b = x + 2;
          try {
               for (let i = 0; i < 42; i++) {
               b >>= 0.0;
               bar(i);
          }
   } catch(e) {
return b + 42;
  }
}

function assertEq(ast, exp){

        if(ast == exp) {
                print("1");
        }

        else{
                print("0");
        }

}

%NeverOptimizeFunction(bar);
%PrepareFunctionForOptimization(foo);
assertEq(49, foo(5.3));

assertEq(49, foo(5.3));
%OptimizeFunctionOnNextCall(foo);

assertEq(49, foo(5.3));
while(1);
```
**최적화 전
1. assertEq에서 foo(5.3)의 결과와 49를 비교 
2. let b = x + 2;에 의해 b는 항상 7.3
3. b >>= 0.0; 으로 인해 b는 7이 됨
4. bar(i)에 의해 i가 5가 되면 ThrowSomething()으로 catch(e)가 실행(가장 가까운 try 문으로 이동)
5. return b + 42;에 의해 결과는 49가 되므로 항상 True(1)이 출력이 됨

**최적화 후
foo 함수를 최적화 하는데 어떠한 취약점으로 인해 Speculative JIT 컴파일러가 return b + 42;의 결과를 바꿔 False(0)이 나올 것으로 추정

## Backtrace 분석
---

분석에 앞서 우선 백트레이스에 대한 이해를 잘못 하고 있었다. 여지껏 Call 된 함수 트리를 보여주는 기능인 줄 알았으나, 그게 아니라 다시 Ret으로 
돌아갈 콜스택을 순서대로 보여주는 기능이었다. (실행된 함수는 무조건 호출자 함수로 돌아오며 그 구조는 스택에 쌓인다. 이를 스택 프레임이라 한다.)

즉, 실행 흐름을 역순으로 분석해야 한다. 

pwndbg로 backtrace 분석을 할 때 유의해야 할 점 몇 가지가 있다.

1. 각 라인별로 "at (소스코드위치):라인넘버" 가 적혀있다. 이는 이 다음 라인의 함수가 실행되기 직전의 소스코드 위치이며, 이 때 넘어온 인자 정보를 볼 수 있다.
2. 만약 특정 라인에 브레이크 포인트를 걸고 싶으면 예)tbreak src/compiler/pipline.cc:770 과 같이 소스 라인으로 브레이크 포인트를 걸 수 있다.
* 이 때 주의해야 할 점은 라인에 적혀있는 각 함수 주소에 브레이크 포인트를 걸어선 안되며, 심볼 브포를 걸 경우에도 레지스터 세팅이 달라지는 경우가 있어 Abort()가 날 수 있다.
( (gdb) rbreak v8::internal::compiler::PipelineCompilationJob::ExecuteJobImpl)와 같이 함수 전체에 브포 거는 건 가능 )
3. 만일 특정 라인에서 조건부 브포를 쓰려면 예)cond 3 ((void*)linkage) == (void*)0x55555bb25a40 등으로 걸 수 있다.
4. 만약 현재 bt 라인에서 인자를 보고 싶다면 info args, Local var을 보고 싶다면 info local을 사용하면 유용하다.
5. JS Builins 관련 함수들은 네이티브 함수가 아니라서 브레이크 포인트가 제대로 안걸린다. (이것도 방법은 있는듯 함)

## 분석 요약
#69 - #46까지는 Builins로 실행되는 JS 함수에 관련된 함수들이므로 분석을 생략한다.
#45 - #39까지는 최적화 함수로 인해 Turbofan으로 런타임하는 과정이다.
#37 - #35까지는 Turbolev 옵션으로 인해 Turboshaft로 파이프라이닝을 하는 과정이다. Maglev -> Turboshaft 단계로 최적화가 될 예정
#34 - #33까지는 Turboshaft를 가기위해 Maglev로 최적화 그래프 빌딩하는 과정이다.
#32 - #30까지는 빌딩된그래프를 Turboshaft에서 노드 프로세싱하는 과정이다. 이후 바인딩 되는 과정에서 취약점이 발생됨.

이후 Turboshaft의 네이티브 코드로 변환된다.

